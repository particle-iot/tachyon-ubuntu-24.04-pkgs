Description: Use `ucontext_t` instead of `ucontext`
 Both Bionic and glibc define a struct called `ucontext_t` but only Bionic
 defines an alias `ucontext_t`. Let's use the more standardized one.
Forwarded: not-needed
--- a/art/runtime/native_stack_dump.cc
+++ b/art/runtime/native_stack_dump.cc
@@ -38,6 +38,7 @@
 #include <stdlib.h>
 #include <sys/time.h>
 #include <sys/types.h>
+#include <sys/ucontext.h>
 
 #include "android-base/file.h"
 #include "android-base/stringprintf.h"
@@ -328,7 +329,7 @@
   }
   std::unique_ptr<Backtrace> backtrace(Backtrace::Create(BACKTRACE_CURRENT_PROCESS, tid, map));
   backtrace->SetSkipFrames(skip_frames);
-  if (!backtrace->Unwind(0, reinterpret_cast<ucontext*>(ucontext_ptr))) {
+  if (!backtrace->Unwind(0, reinterpret_cast<ucontext_t*>(ucontext_ptr))) {
     os << prefix << "(backtrace::Unwind failed for thread " << tid
        << ": " <<  backtrace->GetErrorString(backtrace->GetError()) << ")" << std::endl;
     return;
--- a/art/runtime/arch/x86/fault_handler_x86.cc
+++ b/art/runtime/arch/x86/fault_handler_x86.cc
@@ -282,7 +282,7 @@
                                              uintptr_t* out_return_pc,
                                              uintptr_t* out_sp,
                                              bool* out_is_stack_overflow) {
-  struct ucontext* uc = reinterpret_cast<struct ucontext*>(context);
+  struct ucontext_t* uc = reinterpret_cast<struct ucontext_t*>(context);
   *out_sp = static_cast<uintptr_t>(uc->CTX_ESP);
   VLOG(signals) << "sp: " << std::hex << *out_sp;
   if (*out_sp == 0) {
@@ -325,7 +325,7 @@
   if (!IsValidImplicitCheck(sig)) {
     return false;
   }
-  struct ucontext *uc = reinterpret_cast<struct ucontext*>(context);
+  struct ucontext_t *uc = reinterpret_cast<struct ucontext_t*>(context);
   uint8_t* pc = reinterpret_cast<uint8_t*>(uc->CTX_EIP);
   uint8_t* sp = reinterpret_cast<uint8_t*>(uc->CTX_ESP);
 
@@ -381,7 +381,7 @@
 #endif
   uint8_t checkinst2[] = {0x85, 0x00};
 
-  struct ucontext *uc = reinterpret_cast<struct ucontext*>(context);
+  struct ucontext_t *uc = reinterpret_cast<struct ucontext_t*>(context);
   uint8_t* pc = reinterpret_cast<uint8_t*>(uc->CTX_EIP);
   uint8_t* sp = reinterpret_cast<uint8_t*>(uc->CTX_ESP);
 
@@ -437,7 +437,7 @@
 // address for the previous method is on the stack at ESP.
 
 bool StackOverflowHandler::Action(int, siginfo_t* info, void* context) {
-  struct ucontext *uc = reinterpret_cast<struct ucontext*>(context);
+  struct ucontext_t *uc = reinterpret_cast<struct ucontext_t*>(context);
   uintptr_t sp = static_cast<uintptr_t>(uc->CTX_ESP);
 
   uintptr_t fault_addr = reinterpret_cast<uintptr_t>(info->si_addr);
--- a/art/runtime/arch/arm64/fault_handler_arm64.cc
+++ b/art/runtime/arch/arm64/fault_handler_arm64.cc
@@ -44,7 +44,7 @@
                                              uintptr_t* out_return_pc,
                                              uintptr_t* out_sp,
                                              bool* out_is_stack_overflow) {
-  struct ucontext *uc = reinterpret_cast<struct ucontext *>(context);
+  struct ucontext_t *uc = reinterpret_cast<struct ucontext_t *>(context);
   struct sigcontext *sc = reinterpret_cast<struct sigcontext*>(&uc->uc_mcontext);
   *out_sp = static_cast<uintptr_t>(sc->sp);
   VLOG(signals) << "sp: " << *out_sp;
@@ -77,7 +77,7 @@
   // PC at the point of call.  For Null checks we insert a GC map that is immediately after
   // the load/store instruction that might cause the fault.
 
-  struct ucontext *uc = reinterpret_cast<struct ucontext*>(context);
+  struct ucontext_t *uc = reinterpret_cast<struct ucontext_t*>(context);
   struct sigcontext *sc = reinterpret_cast<struct sigcontext*>(&uc->uc_mcontext);
 
   // Push the gc map location to the stack and pass the fault address in LR.
@@ -106,7 +106,7 @@
       (Thread::ThreadSuspendTriggerOffset<PointerSize::k64>().Int32Value() << 7);
   uint32_t checkinst2 = 0xf9400000;
 
-  struct ucontext *uc = reinterpret_cast<struct ucontext *>(context);
+  struct ucontext_t *uc = reinterpret_cast<struct ucontext_t *>(context);
   struct sigcontext *sc = reinterpret_cast<struct sigcontext*>(&uc->uc_mcontext);
   uint8_t* ptr2 = reinterpret_cast<uint8_t*>(sc->pc);
   uint8_t* ptr1 = ptr2 - 4;
@@ -152,7 +152,7 @@
 
 bool StackOverflowHandler::Action(int sig ATTRIBUTE_UNUSED, siginfo_t* info ATTRIBUTE_UNUSED,
                                   void* context) {
-  struct ucontext *uc = reinterpret_cast<struct ucontext *>(context);
+  struct ucontext_t *uc = reinterpret_cast<struct ucontext_t *>(context);
   struct sigcontext *sc = reinterpret_cast<struct sigcontext*>(&uc->uc_mcontext);
   VLOG(signals) << "stack overflow handler with sp at " << std::hex << &uc;
   VLOG(signals) << "sigcontext: " << std::hex << sc;
--- a/art/runtime/arch/arm/fault_handler_arm.cc
+++ b/art/runtime/arch/arm/fault_handler_arm.cc
@@ -51,7 +51,7 @@
                                              uintptr_t* out_return_pc,
                                              uintptr_t* out_sp,
                                              bool* out_is_stack_overflow) {
-  struct ucontext* uc = reinterpret_cast<struct ucontext*>(context);
+  struct ucontext_t* uc = reinterpret_cast<struct ucontext_t*>(context);
   struct sigcontext *sc = reinterpret_cast<struct sigcontext*>(&uc->uc_mcontext);
   *out_sp = static_cast<uintptr_t>(sc->arm_sp);
   VLOG(signals) << "sp: " << std::hex << *out_sp;
@@ -99,7 +99,7 @@
   // register in order to find the mapping.
 
   // Need to work out the size of the instruction that caused the exception.
-  struct ucontext *uc = reinterpret_cast<struct ucontext*>(context);
+  struct ucontext_t *uc = reinterpret_cast<struct ucontext_t*>(context);
   struct sigcontext *sc = reinterpret_cast<struct sigcontext*>(&uc->uc_mcontext);
   uint8_t* ptr = reinterpret_cast<uint8_t*>(sc->arm_pc);
   uint32_t instr_size = GetInstructionSize(ptr);
@@ -132,7 +132,7 @@
       + Thread::ThreadSuspendTriggerOffset<PointerSize::k32>().Int32Value();
   uint16_t checkinst2 = 0x6800;
 
-  struct ucontext* uc = reinterpret_cast<struct ucontext*>(context);
+  struct ucontext_t* uc = reinterpret_cast<struct ucontext_t*>(context);
   struct sigcontext *sc = reinterpret_cast<struct sigcontext*>(&uc->uc_mcontext);
   uint8_t* ptr2 = reinterpret_cast<uint8_t*>(sc->arm_pc);
   uint8_t* ptr1 = ptr2 - 4;
@@ -197,7 +197,7 @@
 
 bool StackOverflowHandler::Action(int sig ATTRIBUTE_UNUSED, siginfo_t* info ATTRIBUTE_UNUSED,
                                   void* context) {
-  struct ucontext* uc = reinterpret_cast<struct ucontext*>(context);
+  struct ucontext_t* uc = reinterpret_cast<struct ucontext_t*>(context);
   struct sigcontext *sc = reinterpret_cast<struct sigcontext*>(&uc->uc_mcontext);
   VLOG(signals) << "stack overflow handler with sp at " << std::hex << &uc;
   VLOG(signals) << "sigcontext: " << std::hex << sc;
--- a/art/runtime/arch/arm/instruction_set_features_arm.cc
+++ b/art/runtime/arch/arm/instruction_set_features_arm.cc
@@ -223,8 +223,9 @@
                             siginfo_t* si ATTRIBUTE_UNUSED,
                             void* data) {
 #if defined(__arm__)
-  struct ucontext *uc = (struct ucontext *)data;
-  struct sigcontext *sc = &uc->uc_mcontext;
+  struct ucontext_t *uc = (struct ucontext_t *)data;
+  // See the starting chunk of `FaultManager::GetMethodAndReturnPcAndSp()` in `fault_handler_arm.cc`
+  struct sigcontext *sc = reinterpret_cast<struct sigcontext*>(&uc->uc_mcontext);
   sc->arm_r0 = 0;     // Set R0 to #0 to signal error.
   sc->arm_pc += 4;    // Skip offending instruction.
 #else
--- a/art/runtime/arch/mips/fault_handler_mips.cc
+++ b/art/runtime/arch/mips/fault_handler_mips.cc
@@ -43,7 +43,7 @@
                                              uintptr_t* out_return_pc,
                                              uintptr_t* out_sp,
                                              bool* out_is_stack_overflow) {
-  struct ucontext* uc = reinterpret_cast<struct ucontext*>(context);
+  struct ucontext_t* uc = reinterpret_cast<struct ucontext_t*>(context);
   struct sigcontext *sc = reinterpret_cast<struct sigcontext*>(&uc->uc_mcontext);
   *out_sp = static_cast<uintptr_t>(sc->sc_regs[mips::SP]);
   VLOG(signals) << "sp: " << *out_sp;
@@ -77,7 +77,7 @@
   // PC at the point of call.  For Null checks we insert a GC map that is immediately after
   // the load/store instruction that might cause the fault.
 
-  struct ucontext *uc = reinterpret_cast<struct ucontext*>(context);
+  struct ucontext_t *uc = reinterpret_cast<struct ucontext_t*>(context);
   struct sigcontext *sc = reinterpret_cast<struct sigcontext*>(&uc->uc_mcontext);
 
   // Decrement $sp by the frame size of the kSaveEverything method and store
@@ -112,7 +112,7 @@
 // to the overflow region below the protected region.
 
 bool StackOverflowHandler::Action(int sig ATTRIBUTE_UNUSED, siginfo_t* info, void* context) {
-  struct ucontext* uc = reinterpret_cast<struct ucontext*>(context);
+  struct ucontext_t* uc = reinterpret_cast<struct ucontext_t*>(context);
   struct sigcontext *sc = reinterpret_cast<struct sigcontext*>(&uc->uc_mcontext);
   VLOG(signals) << "stack overflow handler with sp at " << std::hex << &uc;
   VLOG(signals) << "sigcontext: " << std::hex << sc;
--- a/art/runtime/arch/mips64/fault_handler_mips64.cc
+++ b/art/runtime/arch/mips64/fault_handler_mips64.cc
@@ -44,7 +44,7 @@
                                              uintptr_t* out_return_pc,
                                              uintptr_t* out_sp,
                                              bool* out_is_stack_overflow) {
-  struct ucontext* uc = reinterpret_cast<struct ucontext*>(context);
+  struct ucontext_t* uc = reinterpret_cast<struct ucontext_t*>(context);
   struct sigcontext *sc = reinterpret_cast<struct sigcontext*>(&uc->uc_mcontext);
   *out_sp = static_cast<uintptr_t>(sc->sc_regs[mips64::SP]);
   VLOG(signals) << "sp: " << *out_sp;
@@ -79,7 +79,7 @@
   // PC at the point of call.  For Null checks we insert a GC map that is immediately after
   // the load/store instruction that might cause the fault.
 
-  struct ucontext *uc = reinterpret_cast<struct ucontext*>(context);
+  struct ucontext_t *uc = reinterpret_cast<struct ucontext_t*>(context);
   struct sigcontext *sc = reinterpret_cast<struct sigcontext*>(&uc->uc_mcontext);
 
   // Decrement $sp by the frame size of the kSaveEverything method and store
@@ -114,7 +114,7 @@
 // to the overflow region below the protected region.
 
 bool StackOverflowHandler::Action(int sig ATTRIBUTE_UNUSED, siginfo_t* info, void* context) {
-  struct ucontext* uc = reinterpret_cast<struct ucontext*>(context);
+  struct ucontext_t* uc = reinterpret_cast<struct ucontext_t*>(context);
   struct sigcontext *sc = reinterpret_cast<struct sigcontext*>(&uc->uc_mcontext);
   VLOG(signals) << "stack overflow handler with sp at " << std::hex << &uc;
   VLOG(signals) << "sigcontext: " << std::hex << sc;
